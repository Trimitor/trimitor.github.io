// dbcutil.js
export class DBCFile {
  constructor(arrayBuffer = null, schema = null) {
    this.schema = schema;
    this.records = [];
    this.strings = new Map(); // string -> offset

    if (arrayBuffer) {
      this.view = new DataView(arrayBuffer);
      this.header = this._readHeader();
      this.records = this._readRecords();
      this.stringBlock = this._readStringBlock();
    } else {
      this.header = {
        magic: 0x43424457, // 'WDBC'
        recordCount: 0,
        fieldCount: schema ? schema.length : 0,
        recordSize: (schema ? schema.length : 0) * 4,
        stringBlockSize: 1,
      };
      this.stringBlock = new Uint8Array([0]); // хотя бы один \0
    }
  }

  // ---------------- Чтение ----------------

  _readHeader() {
    const magic = this.view.getUint32(0, true);
    if (magic !== 0x43424457) throw new Error("Invalid DBC file");
    return {
      magic,
      recordCount: this.view.getUint32(4, true),
      fieldCount: this.view.getUint32(8, true),
      recordSize: this.view.getUint32(12, true),
      stringBlockSize: this.view.getUint32(16, true),
    };
  }

  _readRecords() {
    const { recordCount, fieldCount, recordSize } = this.header;
    const base = 20;
    const records = [];
    for (let i = 0; i < recordCount; i++) {
      const offset = base + i * recordSize;
      const record = [];
      for (let j = 0; j < fieldCount; j++) {
        record.push(this.view.getUint32(offset + j * 4, true));
      }
      records.push(record);
    }
    return records;
  }

  _readStringBlock() {
    const { recordCount, recordSize, stringBlockSize } = this.header;
    const base = 20 + recordCount * recordSize;
    return new Uint8Array(this.view.buffer, base, stringBlockSize);
  }

  getString(offset) {
    if (offset === 0) return "";
    let end = offset;
    while (end < this.stringBlock.length && this.stringBlock[end] !== 0) end++;
    return new TextDecoder("utf-8").decode(this.stringBlock.slice(offset, end));
  }

  // Возвращает объект по схеме
  getRecord(index) {
    const raw = this.records[index];
    if (!this.schema) return raw;

    const obj = {};
    for (let i = 0; i < this.schema.length; i++) {
      const field = this.schema[i];
      const value = raw[i];

      switch (field.type) {
        case "long":
        case "flags":
          obj[field.name] = value >>> 0; // uint32
          break;
        case "float":
          obj[field.name] = new DataView(new Uint32Array([value]).buffer).getFloat32(0, true);
          break;
        case "str":
          obj[field.name] = this.getString(value);
          break;
        default:
          obj[field.name] = value;
      }
    }
    return obj;
  }

  getAllRecords() {
    return this.records.map((_, i) => this.getRecord(i));
  }

  // ---------------- Запись ----------------

  addRecord(obj) {
    if (!this.schema) throw new Error("Schema required");

    const raw = [];
    for (let i = 0; i < this.schema.length; i++) {
      const field = this.schema[i];
      const val = obj[field.name];

      switch (field.type) {
        case "long":
        case "flags":
          raw.push(val >>> 0);
          break;
        case "float":
          const buf = new ArrayBuffer(4);
          new DataView(buf).setFloat32(0, val, true);
          raw.push(new DataView(buf).getUint32(0, true));
          break;
        case "str":
          raw.push(this._getStringOffset(val));
          break;
        default:
          raw.push(val >>> 0);
      }
    }
    this.records.push(raw);
  }

  _getStringOffset(str) {
    if (!str) return 0;
    if (this.strings.has(str)) return this.strings.get(str);

    const encoder = new TextEncoder();
    const bytes = encoder.encode(str + "\0");
    const offset = this.stringBlock.length;

    const newBlock = new Uint8Array(this.stringBlock.length + bytes.length);
    newBlock.set(this.stringBlock, 0);
    newBlock.set(bytes, this.stringBlock.length);

    this.stringBlock = newBlock;
    this.strings.set(str, offset);

    return offset;
  }

  toArrayBuffer() {
    const recordCount = this.records.length;
    const fieldCount = this.schema ? this.schema.length : (this.records[0]?.length ?? 0);
    const recordSize = fieldCount * 4;
    const stringBlockSize = this.stringBlock.length;

    const buffer = new ArrayBuffer(20 + recordCount * recordSize + stringBlockSize);
    const view = new DataView(buffer);

    // header
    view.setUint32(0, 0x43424457, true); // WDBC
    view.setUint32(4, recordCount, true);
    view.setUint32(8, fieldCount, true);
    view.setUint32(12, recordSize, true);
    view.setUint32(16, stringBlockSize, true);

    // records
    let offset = 20;
    for (const rec of this.records) {
      for (let j = 0; j < fieldCount; j++) {
        view.setUint32(offset, rec[j], true);
        offset += 4;
      }
    }

    // string block
    new Uint8Array(buffer, offset).set(this.stringBlock);

    return buffer;
  }
}
